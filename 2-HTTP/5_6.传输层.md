# 传输层

主要协议

1. 面向链接的可靠服务 TCP
2. 无链接的不可靠服务 UDP

## tcp

tcp 是面向链接的，通信之前必须建立好**链接**。点对点传输

> TCP 如何确保可靠传输？

1. 三次握手建立链接之后才开始发包
2. TCP 将包排序并进行错误检查，同时实现虚电路间的连接
3. 数据传输的过程中，每一个数据段都有一个 16 位的编号，将这些编号加起来并取反得出一个校验和，看收到后是否和之前的一致
4. TCP 数据包中包括**序号号和确认答应**，所以未按照顺序收到的包可以被排序
5. 有流量控制、**超时重传**、滑动窗口、拥塞控制的机制

> 为什么要进行流量控制？

为了解决发送方和接收方的速率不一致问题，如果**发送方的速率过快**，接收方处理不过来，只能放在缓存区，**缓存区满了，就只能丢包**了。所以需要进行流量控制

> tcp 拥塞避免的四种算法

1. 慢开始
2. 拥塞控制
3. 快重传
4. 快恢复

> 什么情况会导致重传？

1. TCP 一对一答应，如果丢包了，就会处于僵持状态
2. 在发送时会设置一个定时器，一段时间（这个时间应该略大于一个发送来回的时间）如果没有收到对方 ACK 确认的话，就会重新发送数据，这就是超时重传

### tcp 包的结构

**以太网数据包**(packet)的大小固定，最初是 1518 字节，现在增加到 1522 字节。其中 1500 字节是负载(payload)，22 字节是头信息(head)。即 MTU(Maximum Transmission Unit)为 1500

packet 的结构:
整个 packet 包含 ip 数据包，而 tcp 数据包包含在 ip 数据包里面

> 以太网头部 | ip 头部 | tcp 头部| 应用层数据

由此可以计算得到 tcp 数据包的大小：

MTU 字节大小 1500 - IP 头部信息 20 - TCP 头长度 20 - TCP timestrap option 12 = 1448Byte

tcp 头部长度 20 个字节，包含的成分

> 源端口地址 16bit | 目的端口地址 16 bit -> 4 字节
> 32 位序列号 -> 4 字节
> 32 位确认号 -> 4 字节
> 头部长度|保留|标志 -> 2 字节 | 窗口大小 -> 2 字节
> TCP 校验和 | 紧急指针 -> 4 字节

### tcp 三次握手、四次挥手

TCP 会话的每一端都包含一个**32bit**的**序列号**，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过**确认号**用来通知发送端数据成功接收

tcp 头字段：

1. seq **序号 32 位标识数据段在已发送的数据流中的位置**
2. ack 确认号,验证是否已被接收
3. SYN 用于创建链接和使序号同步
4. ACK 用于表示确认号是否有效
5. FIN 用于表示还有没有数据要传输
6. PSH 用于指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满
7. RST

三次握手的过程：

1. 请求链接：第一次握手 client 向 server 发送一个 SYN 请求打开链接
   - client 设置 syn=1,**随机数 seq** A
2. 链接允许：第二次握手 server 向 client 返回一个合法的 SYN/ACK。
   - server 设置 ack 为上一次握手的 seq+1(A+1)，设置随机的 seq B
3. client 再次响应：第三次握手
   1. client 设置 seq = 第二次握手的 ack(A)
   2. client 设置 ack = 第二次握手的 seq(B)

> 为什么不能是两次握手？

最后一次握手主要是防止**已经失效的连接请求报文**突然又传送到了服务器，从而产生错误和资源的浪费。

1. client 发送了第一次握手的报文且没有丢失，但是在网络节点里面滞留的太久，client 迟迟没有收到 server 响应的第二次握手的报文
2. 此时 client 由于收不到第二次的握手报文，因此重发第一次的报文，server 收到了并三次握手成功，传输了数据后断开了链接
3. 之前滞留的报文发到了 server 端，虽然已经是失效的报文了，但是两次握手的机制就会导致 server 端进入链接状态，导致空耗资源

> 如何释放链接？

1. 数据传输完毕后，双方都可释放连接。
2. 最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态（建立连接。表示两台机器正在通信），
3. 然后客户端主动关闭，服务器被动关闭。

四次挥手过程：

1. 第一次挥手（**client-FIN**）客户端发送 FIN(结束)报文，通知服务器数据已经传输完毕（但是还能接收数据），进入 FIN-WAIT-1（终止等待 1）状态
2. 第二次挥手（**server-ACK**），服务器接收到连接释放报文，发出确认报文，通知客户端我收到了 SYN,发送 ACK(确认)给客户端，告诉对方还有数据要传输完成，服务端就进入了 CLOSE-WAIT（关闭等待）状态
3. 第三次挥手（**server-FIN**）服务器已经传输完毕，再次发送 FIN 通知客户端，数据已经传输完毕，服务端进入 LAST-ACK（最后确认）状态
4. 第四次挥手（**client-ACK**） 客户端再次发送 ACK,进入 TIME_WAIT 状态；服务器和客户端关闭连接；

> 为什么是四次挥手？

1. 关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示**对方不再发送数据了但是还能接收数据**
2. 而**自方**也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后
3. 等全部传输完毕，再发送 FIN 报文给对方来表示同意现在关闭连接
4. 因此，**己方 ACK 和 FIN 一般都会分开发送**，从而导致多了一次。
